# 同步多线程应用程序编写

本项目是实现了同步式的多线程调度。在主线程中，用户自定义任务图，即为每个任务添加直接前驱。当任务创建并打包好后，会提交给线程池，线程池会根据当前池内线程的使用情况进行任务的分配和线程调度。

## 算法流程

##### 主线程

1、初始化ThreadPool，创建用户定义个数的线程数，并置其为空闲状态。

2、初始化所有任务，为各种任务添加前驱（任务之间的依赖关系必须满足拓扑排序），捆绑任务，提交到ThreadPool中。

3、ThreadPool将提交来的任务包解绑，一个一个添加到任务队列中。每添加一个任务，就唤醒一个线程。

4、等所有的任务执行结束后，关闭所有线程，销毁线程池。

##### 子线程

1、在线程创建后，处于闲置阶段，等待线程池的唤醒指令。

2、接受到唤醒指令后，每个子线程会异步遍历ThreadPool的任务队列。遍历一遍后，如果发现有任务满足执行条件，即其没有直接前驱或者直接前驱都已经执行过了，那么我们就执行这个任务，同时将该任务移出任务队列。如果没有，那么就暂时剥夺该线程的时间片一段时间，之后再重新检查消息队列。

如果消息队列为空，那么置该线程为空闲状态。否则，该被唤醒的线程就会一直异步遍历任务队列，直到找到找到可以执行的任务为止。

3、当线程接接收到退出指令时，其将直接返回。

## 类设计

### CSignal

封装了Windows对事件的相应。

### CMutex

封装了异步锁。

### CJob

成员变量：

UINT32 m_index:每一个任务的独立数据，这里代表其在依赖关系图中的索引。

CSignal m_signal:每个任务完成的信号，在任务完成是将其触发。

vector<CSignal*>  m_Precursor:该任务直接前驱的m_signal，用于判断其能否执行。

### BindingJobs

核心成员变量（上下文）：

vector<CJob*> jobs：用于向Pool中提交任务

CThreadPool* pool：任务捆绑包要绑到的具体线程池。

我将BindingJobs做为一个闭包，即有状态（上下文）的函数（个人理解），其重载了括号“（）”运算符。当使用“（）”后，我们的任务将逐一提交给线程池，完成任务调度。

### CThread

核心成员变量：

CThreadPool *m_ThreadPool：每个线程要获取线程池中的数据，比如任务队列、异步锁等。

HANDLE m_Handle:该线程的句柄

CSignal m_AwakeSignal:任务唤醒事件

核心方法：

Invoke：回调函数，即线程的主函数，用于任务的执行和线程状态的设置。

### CThreadPool

核心成员变量：

vector<CThread*> m_WorkerThreads;用于储存所有注册到线程池中的线程

vector<CThread*> m_IdleThreads;用于储存空闲线程

deque<CJob*> m_JobQueue;任务队列

CMutex m_ThreadArrayMtx;异步锁，用于异步访问上述两个线程队列

CMutex m_JobQueueMtx;易步锁，用于异步访问上述任务队列

核心方法：

void CreateWorkerThread();创建线程，并置其为闲置状态

int SubmitJob(BindingJobs jobbinding);逐一提交任务包中的任务，并唤醒线程来执行任务。

